#ifndef ASS6_18CS10021_18CS30040_TRANSLATOR_H
#define ASS6_18CS10021_18CS30040_TRANSLATOR_H

#include <stdio.h>
#include <vector>
#include <cstdlib>
#include <string>
#include <set>
#include <map>
#include <stack>
using namespace std;
#define ext extern
ext map<int,int> mp_set;
ext int size_bool,size_int,size_double,size_pointer,size_char;
ext stack<string> params_stack,strin;
ext stack<int> types_stack,offset_stack,ptrarr_stack;
ext vector<string> strings_label;

class type_n;
class expresn;
class quad; 
class symdata; 
class symtab;
class quad_arr; 
class funct;
class Array;
struct decstring;
struct idstring;
struct expresn;
struct ArgumentList;
ext type_n *glob_type;
ext int glob_width, next_instr, temp_count; 
ext symtab *glob_st, *Current_ST; //Global symbol table pointer
ext quad_arr global_quad_table; //to store all the quads that will be generated by the grammar

enum types
{
	tp_void=0,tp_bool,tp_arr,tp_func,tp_char,tp_int,tp_double,tp_ptr,
};

typedef struct list
{
	int index;
	struct list *next;
}list;

enum opcode{

	//Binary Assignment Operator
	Q_PLUS=1,Q_MINUS,Q_MULT,Q_DIVIDE,Q_MODULO,Q_LEFT_OP,Q_RIGHT_OP,Q_XOR,Q_AND,Q_OR,Q_LOG_AND,Q_LOG_OR,Q_LESS,Q_LESS_OR_EQUAL,Q_GREATER_OR_EQUAL,Q_GREATER,Q_EQUAL,Q_NOT_EQUAL,	//Unary Assignment Operator
	Q_UNARY_MINUS,Q_UNARY_PLUS,Q_COMPLEMENT,Q_NOT,	//Copy Assignment
	Q_ASSIGN,Q_GOTO,	//Conditional Jump
	Q_IF_EQUAL,Q_IF_NOT_EQUAL,Q_IF_EXPRESSION,Q_IF_NOT_EXPRESSION,Q_IF_LESS,Q_IF_GREATER,Q_IF_LESS_OR_EQUAL,Q_IF_GREATER_OR_EQUAL,	//Type Conversions
	Q_CHAR2INT,Q_CHAR2DOUBLE,Q_INT2CHAR,Q_DOUBLE2CHAR,Q_INT2DOUBLE,Q_DOUBLE2INT,
	//Procedure Call
	Q_PARAM,Q_CALL,Q_RETURN,	//Pointer Assignment Operator
	Q_LDEREF,Q_RDEREF,Q_ADDR,	//Array Indexing
	Q_RINDEX,Q_LINDEX,
};

union basic_val
{
	int int_val;
	double double_val;
	char char_val;
};

class type_n{
public:
	int size;    // to save the size of the type
	types basetp; // to save the basic type of the elemnt
	type_n *next; // to save next type_n type for Arrays
	type_n(types t,int sz=1, type_n *n=NULL); //constuctor
	int getSize(); //returns the size
	types getBasetp(); 
	void printSize();
	void print(); 
};

type_n *CopyType(type_n *);
class Array
{
    public:
	string base_arr;
	Array(string ,int ,types );
	types tp;
	
	vector<int> dims;
	int bsize,dimension_size;
	void addindex(int );

};

class funct
{
public:
	vector<types> typelist;
	type_n *rettype;

	funct(vector<types> );
	void print();
};


//class which will be used as building element for symbol table
class symdata{
public:
	string name, var_type;
	int offset, size;
	basic_val i_val;//to store the initialized value for an element stored at symbol table
	type_n *tp_n;//for storing the type of element
	symtab *nest_tab; //to store the pointer to the symbol table to which the current element belongs to
	Array *arr;
	funct *fun;
	void createarray();
	symdata(string n=""); 
	bool isGlobal,isdone,ispresent,isptrarr,isArray, isFunction, isInitialized;
};	

class symtab{
    public:
	string name;			// name of the symbol
	int offset, start_quad, end_quad;				// final offset of this symbol table that will be used in the update function
	vector<symdata*> symbol_tab; //maintaining a list of symbol tables
	symtab();  //constructor
	~symtab(); //destructor
	symdata* lookup(string );// Lookup function searches the variable with name. If the variable is present then returns its pointer location else creates a new entry with its name and returns that pointer
	symdata* lookup_2(string );//To handle global variables
	symdata* search(string ); 
	symdata* gentemp(type_n* ); 
	int no_params;
	void print();
	void update(symdata*,type_n* ,basic_val , symtab *next = NULL);//	
	int function_call(FILE *);
	void function_epilogue(FILE *,int ,int);
    void mark_labels();
	void function_prologue(FILE*,int );
	void global_variables(FILE *);
	void gen_internal_code(FILE *,int);
	
	string assign_reg(int ,int );
	void assign_offset();
	void function_restore(FILE *);
	int findg(string );
};

struct expresn{
	symdata* loc;
	type_n* type;
	list* falselist, *truelist;
	bool isArray,isPointer,isstringing;
	int ind_str;
	symdata *poss_array,*arr;
};
list* makelist(int );  
list* merge(list *,list *); 
void backpatch(list *,int ); 
void conv2Bool(expresn *); 
void typecheck(expresn *,expresn *,bool isAss = false);
void print_list(list *);
class quad{
    public:
        string arg1,result,arg2;
        opcode op;
        void print_arg();
        quad(opcode,string,string,string);
};

struct decstring {
	type_n *type;						
	int width;					
};
struct ArgumentList{
	vector<expresn*> *arguments;
};

struct idstring {
	symdata *loc;					
	string *name;						
};

struct strstr{
	type_n lop;
	string name;
};

class quad_arr{
public:
	vector<quad> arr;//to store the list of quads
	quad_arr();
	void emit(opcode , string def1="", string def2="", string res=""); //emit used for operations with 3 inputs
	void emit(opcode , char , string operand=""); //emit for assignment of char
	void emit2(opcode,string arg1="", string arg2="", string result="");
    void emit(opcode , int , string operand="");  // emit for assignment of int
	void emit(opcode , double , string operand=""); //emit for assignment of double
	
	void print();  
};

#endif
